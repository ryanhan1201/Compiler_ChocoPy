import java.util.ArrayList;
import java.util.List;

import java_cup.runtime.*;
import chocopy.common.astnodes.*;

/* The following code section is copied verbatim to the generated
 * parser class. */
parser code {:

    /* The following fields and methods deal with error reporting
     * Avoid changing these unless you know what you are doing. */

    /** Node that accumulates error messages to be added to the Program
     *  node produced as a result. */
    public final Errors errors = new Errors(new ArrayList<>());

    /** Return the Program node that results from parsing the stream of
     *  tokens produced by lexical analysis.  In the case of syntax errors,
     *  the program may be empty, but will have error messages. */
    public Program parseProgram(boolean debug) {
        try {
            Symbol result = debug ? debug_parse() : parse();
            if (result == null || !(result.value instanceof Program)) {
                return new Program(new Location(0, 0), new Location(0, 0),
                                   new ArrayList<Declaration>(),
                                   new ArrayList<Stmt>(),
                                   errors);
            } else {
                return (Program) result.value;
            }
        } catch (RuntimeException excp) {
            throw excp;
        } catch (Exception excp) {
            String msg =
                String.format("Internal parser error detected: %s%n", excp);
            throw new AssertionError(msg);
        }
    }

    @Override
    public SymbolFactory getSymbolFactory() {
        return ((ChocoPyLexer) getScanner()).symbolFactory;
    }

    @Override
    public void syntax_error(Symbol cur_token) {
                String token = symbl_name_from_id(cur_token.sym);
                String text = ((ChocoPyLexer) getScanner()).yytext();
                errors.syntaxError(
                    ((ComplexSymbolFactory.ComplexSymbol) cur_token).xleft,
                    ((ComplexSymbolFactory.ComplexSymbol) cur_token).xright,
                    "Parse error near token %s: %s", token, text);
    }

    @Override
    public void unrecovered_syntax_error(Symbol cur_token) {
        /* Do not die */
    }
:}


/**************************************************************************
 *              FEEL FREE TO MODIFY ANYTHING BELOW THIS LINE              
 *
 * The rules provided below parse expressions of the form <INT> + <INT> + ... 
 * You can re-use these rules or edit them as you wish. The start rule
 * should return a node of type Program.
 *
 * Tips: Production rules are usually followed by action code that will be
 * copied to the generated parser to be executed immediately after a reduce
 * operation; that is, when a production rule has been matched. You can name
 * a nonterminal or terminal symbol in a production rule using the colon
 * notation, e.g. expr_stmt ::= expr:e, to get the AST node for the matched
 * expression. In the action code, `e` will be a variable of whatever type
 * has been declared for the corresponding nonterminal, such as `Expr`.
 * Therefore, you can construct an AST Node of type `ExprStmt` with `e` in the
 * constructor: `new ExprStmt(exleft, exright, e)`
 *
 * The variables `exleft` and `exright` are automatically generated by CUP
 * and contain Location objects for the start and end of the expression `e`.
 * You can collect start and line number info for AST nodes by taking the
 * location of the left end of the leftmost symbol in a rule and the
 * location of the right end of the rightmost symbol. The auto-generated
 * variables have names `<sym>xleft` and `<sym>xright`, where <sym> is the
 * name given to the symbol using the colon notation.
 *
 * When you have nonterminals that are lists of things, e.g. List<Stmt> or
 * List<Declaration>, it is helpful to get the leftmost and rightmost
 * source location from within this list; we have provided some utility
 * functions below to do just that.
 **************************************************************************/


/* The following code section is copied verbatim to the class that performs
 * production-rule actions. */
action code {:

    /** Return a mutable list initially containing the single value ITEM. */
    <T> List<T> single(T item) {
        List<T> list = new ArrayList<>();
        if (item != null) {
            list.add(item);
        }
        return list;
    }

    /** If ITEM is non-null, appends it to the end of LIST.  Then returns
     *  LIST. */
    <T> List<T> combine(List<T> list, T item) {
        if (item != null) {
            list.add(item);
        }
        return list;
    }

    /** Return a mutable empty list. */
    <T> List<T> empty() {
        return new ArrayList<T>();
    }

    /** Return the leftmost non-whitespace location in NODES, or null if NODES
     *  is empty.  Assumes that the nodes of NODES are ordered in increasing
     *  order of location, from left to right. */
    ComplexSymbolFactory.Location getLeft(List<? extends Node> nodes) {
        if (nodes.isEmpty()) {
            return null;
        }
        Node first = nodes.get(0);
        return new ComplexSymbolFactory.Location(first.getLocation()[0],
                                                 first.getLocation()[1]);
    }

    ComplexSymbolFactory.Location getRight(List<? extends Node> nodes) {
            if (nodes.isEmpty()) {
                return null;
            }
            Node last = nodes.get(nodes.size() - 1);
            return new ComplexSymbolFactory.Location(last.getLocation()[2],
                                                     last.getLocation()[3]);
        }

:}

/* Terminal symbols (tokens returned by the lexer).  The declaration
 *     terminal <identifier1>, <identifier2>, ...;
 * declares each <identifieri> as the denotation of a distinct type terminal
 * symbol for use in the grammar.  The declaration
 *     terminal <type> <identifier1>, ...;
 * does the same, and in addition indicates that the lexer supplies a
 * semantic value of type <type> for these symbols that may be referenced
 * in actions ( {: ... :} ).
 */
terminal NEWLINE;
terminal INDENT;
terminal DEDENT;

//ASK ABOUT NEED OF STRING VARIABLE TYPE OR INTEGER TYPE AND STUFF

//Type Literals
//terminal String STRING, IDSTRING, IDENTIFIER;
terminal Integer NUMBER;
//terminal TRUE, FALSE;
//terminal NONE; //does NONE need class typing?
//terminal ID; //should it be type String?
terminal NONE, AS, ASSERT, ASYNC, AWAIT;
terminal BREAK, CLASS, CONTINUE, DEF, DEL, ELIF, ELSE;
terminal EXCEPT, FINALLY, FOR, FROM, GLOBAL, IF, IMPORT;
terminal IN, LAMBDA, NONLOCAL, PASS, RAISE;
terminal RETURN, TRY, WHILE, WITH, YIELD, COLON;
terminal NEG;

terminal String IDENTIFIER, STRING, IDSTRING;
terminal String PLUS, MINUS, TIMES, DIV, MOD, NOT, AND, OR;
terminal String LESS, GREAT, LESSEQ, GREATEQ;
terminal String FALSE, TRUE;
terminal String EQ, NOTEQ, ASSIGN;
terminal String LEFTPAREN, RIGHTPAREN, LEFTBRACKET, RIGHTBRACKET;
terminal String COMMA, PERIOD, ARROW;
terminal String IS;


/* Returned by the lexer for erroneous tokens.  Since it does not appear in
 * the grammar, it indicates a syntax error. */
terminal UNRECOGNIZED;

/* Nonterminal symbols (defined in production rules below).
 * As for terminal symbols,
 *     non terminal <type> <identifier1>, ..., <identifiern>;
 * defines the listed nonterminal identifier symbols to have semantic values
 * of type <type>. */
non terminal Program           program;
non terminal Declaration       program_head, class_dec, func_dec;
non terminal List<Declaration> program_head_lst, class_body, class_body_def_list, declaration_list, opt_class_body_def_list;
non terminal List<Stmt>        def_list, stmt_list, opt_stmt_list, block, opt_elseif, else, elif_list, opt_elseif_list, else_block;
non terminal Stmt              stmt, expr_stmt, return_stmt, assign_stmt, if_stmt, while_stmt, for_stmt, elif;


non terminal Expr              expr, binary_expr, unary_expr, if_expr, call_expr, list_expr, opt_ret_expr, index_expr, target, cexpr;
non terminal MemberExpr        member_expr;
non terminal List<Expr>        mult_target, opt_expr_lst, expr_lst;
non terminal Literal           literal, non_literal, string_literla, integer_literal, bool_literal;
non terminal Errors            errors;
non terminal CompileErrors     compileError;

non terminal Identifier        id;
non terminal Declaration       declaration, class_def, var_def, global_def, nonlocal_decl, global_decl;
non terminal FuncDef           func_body, func_def;
non terminal TypedVar          typed_var;
non terminal List<TypedVar>    typed_var_list, opt_typed_var_list;
non terminal TypeAnnotation    type_annotation, type, ret_type;
non terminal ClassType         class_type;
non terminal ListType          list_type;
/* Precedences (lowest to highest) for resolving what would otherwise be
 * ambiguities in the form of shift/reduce conflicts.. */
precedence right IF, ELSE;
precedence left OR;
precedence left AND;
precedence nonassoc NOT;
precedence nonassoc EQ, NOTEQ, LESS, GREAT, LESSEQ, GREATEQ, IS;
precedence left PLUS, MINUS;
precedence left TIMES, DIV, MOD;
precedence nonassoc NEG;
precedence left PERIOD, LEFTBRACKET, RIGHTBRACKET;

/* The start symbol. */
start with program;


/*****  GRAMMAR RULES *****/

program ::= program_head_lst:d opt_stmt_list:s          {: RESULT = new Program(getLeft(d), s.isEmpty()? getRight(d) : getRight(s), d, s, errors);:}
        | opt_stmt_list:s                               {: RESULT = new Program(getLeft(s), getRight(s), empty(), s, errors); :}
        | error program:p                               {: RESULT = p; :}
        ;

/* DECLARATIONS */
program_head_lst ::= program_head:p            {: RESULT = single(p); :}
                | program_head_lst:plst program_head:p  {: RESULT = combine(plst, p); :}
                | program_head_lst:plst error           {: RESULT = plst; :}
                ;

program_head ::=  var_def:v         {: RESULT = v; :}
                | func_def:f        {: RESULT = f; :}
                | class_def:c       {: RESULT = c; :}
                ;
/* CLASS */
class_def ::= CLASS:c id:id1 LEFTPAREN id:id2 RIGHTPAREN COLON NEWLINE INDENT class_body:cbody DEDENT
                {: RESULT = new ClassDef(cxleft, getRight(cbody), id1, id2, cbody); :}
                ;
class_body ::= PASS NEWLINE         {: RESULT = empty(); :}
                | error class_body:cb     {: RESULT = cb; :}
                | opt_class_body_def_list:l   {: RESULT = l; :}
                ;
opt_class_body_def_list ::= class_body_def_list:c   {: RESULT = c; :}
                | {: RESULT = empty(); :}
                ;
class_body_def_list ::= class_dec:c                     {: RESULT = single(c); :}
                        | class_body_def_list:lst class_dec:c     {: RESULT = combine(lst, c); :}
                        | class_body_def_list:lst error          {: RESULT = lst; :}
                ;
class_dec ::= var_def:v         {: RESULT = v;:}
            | func_def:f        {: RESULT = f; :}
                ;
class_type ::= IDENTIFIER:id            {: RESULT = new ClassType(idxleft, idxright, id); :}
            | IDSTRING:idstr    {: RESULT = new ClassType(idstrxleft, idstrxright, idstr); :}
                ;

/* FUNCTION */

func_def ::= DEF:d id:id LEFTPAREN opt_typed_var_list:params RIGHTPAREN ret_type:r COLON:c NEWLINE INDENT func_body:fb DEDENT
               {: RESULT = new FuncDef(dxleft, fbxright, id, params.isEmpty() ? empty() : params, r == null ? new ClassType(cxleft, cxright, "<None>") : r, fb.declarations, fb.statements); :}
            ;
opt_typed_var_list ::=          {: RESULT = empty(); :}
            | typed_var_list:t  {: RESULT = t; :}
            ;
typed_var_list ::= typed_var:t                                {: RESULT = single(t); :}
                   | typed_var_list:tlist COMMA typed_var:t   {: RESULT = combine(tlist, t); :}
            ;
ret_type ::= ARROW type:retType     {: RESULT = retType; :}
            |                       {: RESULT = null; :}
            ;
func_body ::= declaration_list:dl stmt_list:sl      {: RESULT = new FuncDef(null, null, null, null, null, dl, sl); :}
            | stmt_list:sl                          {: RESULT = new FuncDef(null, null, null, null, null, empty(), sl); :}
            | error func_body:fb                    {: RESULT = fb; :}
            ;
declaration_list ::= func_dec:f     {: RESULT = single(f); :}
                    | declaration_list:lst func_dec:f  {: RESULT = combine(lst, f); :}
                    | declaration_list:lst error        {: RESULT = lst; :}
            ;
func_dec ::= var_def:v          {: RESULT = v; :}
            | func_def:f        {: RESULT = f; :}
            | global_decl:g     {: RESULT = g; :}
            | nonlocal_decl:l   {: RESULT = l; :}
            ;
global_decl ::= GLOBAL:g id:id NEWLINE      {: RESULT = new GlobalDecl(gxleft, idxright, id); :}
            ;
nonlocal_decl ::= NONLOCAL:n id:id NEWLINE  {: RESULT = new NonLocalDecl(nxleft, idxright, id); :}
            ;

/* VARIABLES */
var_def ::= typed_var:t ASSIGN literal:l NEWLINE    {:  RESULT = new VarDef(txleft, lxright, t, l); :}
            ;
typed_var ::= id:id COLON type:t    {: RESULT = new TypedVar(idxleft, txright, id, t); :}
            ;
type ::= class_type:c    {: RESULT = c; :}
         | list_type:l   {: RESULT = l; :}
            ;
list_type ::= LEFTBRACKET:lb type:t RIGHTBRACKET:rb     {: RESULT = new ListType(lbxleft, rbxright, t); :}
            ;

/* STATEMENTS */

opt_stmt_list ::=                    {: RESULT = empty(); :}
                | stmt_list:s        {: RESULT = s; :}
            ;
stmt_list ::= stmt:s                 {: RESULT = single(s); :}
            | stmt_list:l stmt:s     {: RESULT = combine(l, s); :}
            | stmt_list:l error      {: RESULT = l; :} // | {: result = empty(); :}
            /* If there is a syntax error in the source, this says to discard
             * symbols from the parsing stack and perform reductions until
             * there is a stmt_list on top of the stack, and then to discard
             * input symbols until it is possible to shift again, reporting
             * a syntax error. */
            ;
stmt ::= expr_stmt:s NEWLINE {: RESULT = s; :}
            | IF:i expr:cond COLON block:b else_block:e2
                    {: Location right = b.isEmpty() ? condxright : getRight(b);
                        right = e2.isEmpty() ? right : getRight(e2);
                        RESULT = new IfStmt(ixleft, right, cond, b, e2); :}
            | WHILE:w expr:cond COLON:c block:b
                    {: RESULT = new WhileStmt(wxleft, b.isEmpty() ? cxright : getRight(b), cond, b); :}
            | FOR:f id:id IN:i expr:e COLON:c block:b
                    {: RESULT = new ForStmt(fxleft, b.isEmpty() ? cxright : getRight(b), id, e, b); :}
            ;
else_block ::=                              {: RESULT = empty(); :}
            | ELSE COLON block:b            {: RESULT = b; :}
            | ELIF:e expr:cond COLON block:b else_block:e2
                            {: Location right = b.isEmpty() ? condxright : getRight(b);
                                right = e2.isEmpty() ? right : getRight(e2);
                                IfStmt ifStmt = new IfStmt(exleft, right, cond, b, e2);
                                RESULT = single(ifStmt); :}
            ;
expr_stmt ::= expr:e                    {: RESULT = new ExprStmt(exleft, exright, e); :}
            | error
            | PASS:p                    {: RESULT = null; :}
            | RETURN:r expr:e           {: RESULT = new ReturnStmt(rxleft, exright, e);:}
            | RETURN:r                  {: RESULT = new ReturnStmt(rxleft, rxright, null); :}
            | mult_target:t expr:e      {: RESULT = new AssignStmt(txleft, exright, t, e); :}
            ;




literal ::= NONE:na             {: RESULT = new NoneLiteral(naxleft, naxright); :}
            | TRUE:t            {: RESULT = new BooleanLiteral(txleft, txright, Boolean.parseBoolean(t)); :}
            | FALSE:f           {: RESULT = new BooleanLiteral(fxleft, fxright, Boolean.parseBoolean(f)); :}
            | NUMBER:i          {: RESULT = new IntegerLiteral(ixleft, ixright, i); :}
            | IDSTRING:idstr    {: RESULT = new StringLiteral(idstrxleft, idstrxright, idstr); :}
            | STRING:s          {: RESULT = new StringLiteral(sxleft, sxright, s); :}
            ;

mult_target ::= target:t ASSIGN                 {: RESULT = single(t); :}
            | mult_target:m target:t ASSIGN     {: RESULT = combine(m, t); :}
            ;
expr ::= cexpr:e                                    {: RESULT = e; :}
            | NOT:not expr:e                        {: RESULT = new UnaryExpr(notxleft, exright, not, e); :}
            | expr:e1 AND:and expr:e2               {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, and, e2); :}
            | expr:e1 OR:or expr:e2                 {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, or, e2); :}
            | expr:e1 IF expr:e2 ELSE expr:e3       {: RESULT = new IfExpr(e1xleft, e3xright, e2, e1, e3); :}
            ;
cexpr ::= literal:l                                                 {: RESULT = l; :}
            | target:t                                              {: RESULT = t; :}
            | LEFTBRACKET:lb expr_lst:l RIGHTBRACKET:rb             {: RESULT = new ListExpr(lbxleft, rbxright, l); :}
            | LEFTBRACKET:lb RIGHTBRACKET:rb                        {: RESULT = null; :}
            | LEFTPAREN expr:e RIGHTPAREN                           {: RESULT = e; :}
            | member_expr:m LEFTPAREN RIGHTPAREN:r                  {: RESULT = new MethodCallExpr(mxleft, rxright, m, empty()); :}
            | member_expr:m LEFTPAREN expr_lst:l RIGHTPAREN:r       {: RESULT = new MethodCallExpr(mxleft, rxright, m, l); :}
            | IDENTIFIER:id LEFTPAREN opt_expr_lst:l RIGHTPAREN:r   {: RESULT = new CallExpr(idxleft, rxright, new Identifier(idxleft, idxright, id), l); :}
            | binary_expr:e                                         {: RESULT = e; :}
            | MINUS:neg cexpr:e                                     {: RESULT = new UnaryExpr(negxleft, exright, neg, e); :} %prec NEG
            ;
binary_expr ::= cexpr:e1 PLUS:op cexpr:e2
                        {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
            | cexpr:e1 MINUS:op cexpr:e2
                        {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
            | cexpr:e1 TIMES:op cexpr:e2
                        {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
            | cexpr:e1 DIV:op cexpr: e2
                        {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
            | cexpr:e1 MOD:op cexpr:e2
                        {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
            | cexpr:e1 EQ:op cexpr:e2
                        {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
            | cexpr:e1 NOTEQ:op cexpr:e2
                        {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
            | cexpr:e1 LESSEQ:op cexpr:e2
                        {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
            | cexpr:e1 GREATEQ:op cexpr:e2
                        {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
            | cexpr:e1 LESS:op cexpr:e2
                        {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
            | cexpr:e1 GREAT:op cexpr:e2
                        {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
            | cexpr:e1 IS:op cexpr:e2
                        {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
            ;
opt_expr_lst ::=                {: RESULT = empty(); :}
            | expr_lst: e       {: RESULT = e; :}
            ;
expr_lst ::=  expr:e                        {: RESULT = single(e); :}
            | expr_lst:l COMMA expr:e       {: RESULT = combine(l, e); :}
            ;
block ::= NEWLINE INDENT stmt_list:sl DEDENT    {: RESULT = sl; :}
            ;

id ::= IDENTIFIER:id    {: RESULT = new Identifier(idxleft, idxright, id); :}
            ;
member_expr ::= cexpr:e PERIOD id:id
                        {: RESULT = new MemberExpr(exleft, idxright, e, id); :}
            ;
index_expr ::= cexpr:e1 LEFTBRACKET expr:e2 RIGHTBRACKET:rb
                        {: RESULT = new IndexExpr(e1xleft, rbxright, e1, e2); :}
             ;
target ::= id:id            {: RESULT = id; :}
          | member_expr:e   {: RESULT = e; :}
          | index_expr:e    {: RESULT = e; :}
          ;


